-- ADC_ADC.vhd

-- This file was auto-generated from altera_modular_adc_hw.tcl.  If you edit it your changes
-- will probably be lost.
-- 
-- Generated using ACDS version 18.1 625

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity ADC_ADC is
	generic (
		is_this_first_or_second_adc : integer := 1
	);
	port (
		clock_clk                  : in  std_logic                     := '0';             --            clock.clk
		reset_sink_reset_n         : in  std_logic                     := '0';             --       reset_sink.reset_n
		adc_pll_clock_clk          : in  std_logic                     := '0';             --    adc_pll_clock.clk
		adc_pll_locked_export      : in  std_logic                     := '0';             --   adc_pll_locked.export
		sequencer_csr_address      : in  std_logic                     := '0';             --    sequencer_csr.address
		sequencer_csr_read         : in  std_logic                     := '0';             --                 .read
		sequencer_csr_write        : in  std_logic                     := '0';             --                 .write
		sequencer_csr_writedata    : in  std_logic_vector(31 downto 0) := (others => '0'); --                 .writedata
		sequencer_csr_readdata     : out std_logic_vector(31 downto 0);                    --                 .readdata
		sample_store_csr_address   : in  std_logic_vector(6 downto 0)  := (others => '0'); -- sample_store_csr.address
		sample_store_csr_read      : in  std_logic                     := '0';             --                 .read
		sample_store_csr_write     : in  std_logic                     := '0';             --                 .write
		sample_store_csr_writedata : in  std_logic_vector(31 downto 0) := (others => '0'); --                 .writedata
		sample_store_csr_readdata  : out std_logic_vector(31 downto 0);                    --                 .readdata
		sample_store_irq_irq       : out std_logic                                         -- sample_store_irq.irq
	);
end entity ADC_ADC;

architecture rtl of ADC_ADC is
	component ADC_ADC_control_internal is
		port (
			clk               : in  std_logic                     := 'X';             -- clk
			cmd_valid         : in  std_logic                     := 'X';             -- valid
			cmd_channel       : in  std_logic_vector(4 downto 0)  := (others => 'X'); -- channel
			cmd_sop           : in  std_logic                     := 'X';             -- startofpacket
			cmd_eop           : in  std_logic                     := 'X';             -- endofpacket
			cmd_ready         : out std_logic;                                        -- ready
			rst_n             : in  std_logic                     := 'X';             -- reset_n
			rsp_valid         : out std_logic;                                        -- valid
			rsp_channel       : out std_logic_vector(4 downto 0);                     -- channel
			rsp_data          : out std_logic_vector(11 downto 0);                    -- data
			rsp_sop           : out std_logic;                                        -- startofpacket
			rsp_eop           : out std_logic;                                        -- endofpacket
			clk_in_pll_c0     : in  std_logic                     := 'X';             -- clk
			clk_in_pll_locked : in  std_logic                     := 'X'              -- export
		);
	end component ADC_ADC_control_internal;

	component ADC_ADC_sequencer_internal is
		port (
			clk         : in  std_logic                     := 'X';             -- clk
			rst_n       : in  std_logic                     := 'X';             -- reset_n
			cmd_ready   : in  std_logic                     := 'X';             -- ready
			cmd_valid   : out std_logic;                                        -- valid
			cmd_channel : out std_logic_vector(4 downto 0);                     -- channel
			cmd_sop     : out std_logic;                                        -- startofpacket
			cmd_eop     : out std_logic;                                        -- endofpacket
			addr        : in  std_logic                     := 'X';             -- address
			read        : in  std_logic                     := 'X';             -- read
			write       : in  std_logic                     := 'X';             -- write
			writedata   : in  std_logic_vector(31 downto 0) := (others => 'X'); -- writedata
			readdata    : out std_logic_vector(31 downto 0)                     -- readdata
		);
	end component ADC_ADC_sequencer_internal;

	component ADC_ADC_sample_store_internal is
		port (
			clk         : in  std_logic                     := 'X';             -- clk
			rst_n       : in  std_logic                     := 'X';             -- reset_n
			rsp_valid   : in  std_logic                     := 'X';             -- valid
			rsp_channel : in  std_logic_vector(4 downto 0)  := (others => 'X'); -- channel
			rsp_sop     : in  std_logic                     := 'X';             -- startofpacket
			rsp_eop     : in  std_logic                     := 'X';             -- endofpacket
			rsp_data    : in  std_logic_vector(11 downto 0) := (others => 'X'); -- data
			addr        : in  std_logic_vector(6 downto 0)  := (others => 'X'); -- address
			read        : in  std_logic                     := 'X';             -- read
			write       : in  std_logic                     := 'X';             -- write
			writedata   : in  std_logic_vector(31 downto 0) := (others => 'X'); -- writedata
			readdata    : out std_logic_vector(31 downto 0);                    -- readdata
			irq         : out std_logic                                         -- irq
		);
	end component ADC_ADC_sample_store_internal;

	signal sequencer_internal_command_valid         : std_logic;                     -- sequencer_internal:cmd_valid -> control_internal:cmd_valid
	signal sequencer_internal_command_ready         : std_logic;                     -- control_internal:cmd_ready -> sequencer_internal:cmd_ready
	signal sequencer_internal_command_channel       : std_logic_vector(4 downto 0);  -- sequencer_internal:cmd_channel -> control_internal:cmd_channel
	signal sequencer_internal_command_startofpacket : std_logic;                     -- sequencer_internal:cmd_sop -> control_internal:cmd_sop
	signal sequencer_internal_command_endofpacket   : std_logic;                     -- sequencer_internal:cmd_eop -> control_internal:cmd_eop
	signal control_internal_response_valid          : std_logic;                     -- control_internal:rsp_valid -> sample_store_internal:rsp_valid
	signal control_internal_response_data           : std_logic_vector(11 downto 0); -- control_internal:rsp_data -> sample_store_internal:rsp_data
	signal control_internal_response_channel        : std_logic_vector(4 downto 0);  -- control_internal:rsp_channel -> sample_store_internal:rsp_channel
	signal control_internal_response_startofpacket  : std_logic;                     -- control_internal:rsp_sop -> sample_store_internal:rsp_sop
	signal control_internal_response_endofpacket    : std_logic;                     -- control_internal:rsp_eop -> sample_store_internal:rsp_eop

begin

	is_this_first_or_second_adc_check : if is_this_first_or_second_adc /= 1 generate
		assert false report "Supplied generics do not match expected generics" severity Failure;
	end generate;

	control_internal : component ADC_ADC_control_internal
		port map (
			clk               => clock_clk,                                --         clock.clk
			cmd_valid         => sequencer_internal_command_valid,         --       command.valid
			cmd_channel       => sequencer_internal_command_channel,       --              .channel
			cmd_sop           => sequencer_internal_command_startofpacket, --              .startofpacket
			cmd_eop           => sequencer_internal_command_endofpacket,   --              .endofpacket
			cmd_ready         => sequencer_internal_command_ready,         --              .ready
			rst_n             => reset_sink_reset_n,                       --    reset_sink.reset_n
			rsp_valid         => control_internal_response_valid,          --      response.valid
			rsp_channel       => control_internal_response_channel,        --              .channel
			rsp_data          => control_internal_response_data,           --              .data
			rsp_sop           => control_internal_response_startofpacket,  --              .startofpacket
			rsp_eop           => control_internal_response_endofpacket,    --              .endofpacket
			clk_in_pll_c0     => adc_pll_clock_clk,                        -- adc_pll_clock.clk
			clk_in_pll_locked => adc_pll_locked_export                     --   conduit_end.export
		);

	sequencer_internal : component ADC_ADC_sequencer_internal
		port map (
			clk         => clock_clk,                                --      clock.clk
			rst_n       => reset_sink_reset_n,                       -- reset_sink.reset_n
			cmd_ready   => sequencer_internal_command_ready,         --    command.ready
			cmd_valid   => sequencer_internal_command_valid,         --           .valid
			cmd_channel => sequencer_internal_command_channel,       --           .channel
			cmd_sop     => sequencer_internal_command_startofpacket, --           .startofpacket
			cmd_eop     => sequencer_internal_command_endofpacket,   --           .endofpacket
			addr        => sequencer_csr_address,                    --        csr.address
			read        => sequencer_csr_read,                       --           .read
			write       => sequencer_csr_write,                      --           .write
			writedata   => sequencer_csr_writedata,                  --           .writedata
			readdata    => sequencer_csr_readdata                    --           .readdata
		);

	sample_store_internal : component ADC_ADC_sample_store_internal
		port map (
			clk         => clock_clk,                               --            clock.clk
			rst_n       => reset_sink_reset_n,                      --       reset_sink.reset_n
			rsp_valid   => control_internal_response_valid,         --         response.valid
			rsp_channel => control_internal_response_channel,       --                 .channel
			rsp_sop     => control_internal_response_startofpacket, --                 .startofpacket
			rsp_eop     => control_internal_response_endofpacket,   --                 .endofpacket
			rsp_data    => control_internal_response_data,          --                 .data
			addr        => sample_store_csr_address,                --              csr.address
			read        => sample_store_csr_read,                   --                 .read
			write       => sample_store_csr_write,                  --                 .write
			writedata   => sample_store_csr_writedata,              --                 .writedata
			readdata    => sample_store_csr_readdata,               --                 .readdata
			irq         => sample_store_irq_irq                     -- interrupt_sender.irq
		);

end architecture rtl; -- of ADC_ADC
